#!/usr/bin/env bash
#
# tpddclient.sh - TPDD1 client in (almost) pure bash
# Brian K. White b.kenyon.w@gmail.com
# https://archive.org/details/TandyPortableDiskDriveSoftwareManual26-3808s/

# TODOS: Many ;)
# * %done progress bar for load and save
#   For load, do ls first to get the file size.
#   For save, use #hex[] after file_to_hex().
# * ls after every command?
# * 2 or 3-column ls format? (so a full disk still fits on screen)
# * FDC commands
# * TPDD2
# * Refactor the global variable names to have a consistent scheme.
# * Help screen
# * Figure out what's really going on why you can't actually change
#   read_timout very far from 100ms without it all breaking.
# * give lcmd_save() an option to append just for completeness.

###############################################################################
# config

# verbose/debug
# 0/unset=normal, 1=verbose, >1=more verbose, 3=log all tty traffic to files
# DEBUG=1 ./tpddclient ...
v=${DEBUG:-0}

# platform differences
			stty_f="-F" TPDD_TTY_PREFIX=ttyUSB		# linux
case "${OSTYPE,,}" in
	*bsd*) 		stty_f="-f" TPDD_TTY_PREFIX=ttyU ;;		# *bsd
	darwin*) 	stty_f="-f" TPDD_TTY_PREFIX=cu.usbserial- ;;	# osx
esac

# stty flags to set the serial port parameters & tty behavior
# For 9600-only drives like FB-100 or FDD19, change 19200 to 9600
# (FB-100/FDD19 can run at 19200 by removing the solder blob from dip switch 1)
# To disable RTS/CTS hardware flow control, change "crtscts" to "-crtscts"
STTY_FLAGS="19200 crtscts raw pass8 -echo clocal cread flusho -drain"

# read timeout in ms
# When issuing the "read" command to read bytes from the serial port, wait this
# long (in ms) for a byte to appear before giving up.
# Smaller numbers make faster response but use more cpu (tighter polling loop).
READ_TIMEOUT_MS=100

# Default tpdd_wait() timout in ms
# Wait this long (by default) for the drive to respond after issuing a command.
# Some commands like dirent(get_first) and close can take 2 seconds to respond.
# Some commands like format take 100 seconds.
TPDD_WAIT_TIMEOUT_MS=5000

# true/false - Automatically convert filenames to Floppy/Flopy2-compatible 6.2 .
# When saving, pad to %-6s.%-2s  : "A.BA"      -> "A     .BA"
# When loading, strip all spaces : "A     .BA" -> "A.BA"
# You need to do this to be compatible with Floppy, Flopy2, TS-DOS, etc.
# But the drive doesn't care, and Model T's are not the only TPDD users(1).
# So the automatic 6.2 padding can be disabled by setting this to false.
# This can be done at run-time from the commandline:
#     $> FLOPPY_COMPAT=false ./tpddclient save myfilename.exe
# Even when enabled, if a filename wouldn't fit within 6.2, then it is
# not modified, so enabled generally does the expected thing automatically.
# (1) TANDY WP-2, Brother knitting machines, Cambridge Z-88, MS-DOS & most OS's
: ${FLOPPY_COMPAT:=true}

# end of config
###############################################################################

###############################################################################
# drive operating modes
typeset -ra mode=(
	[0]=fdc		# "FDC mode"
	[1]=opr		# "operation mode"
)

###############################################################################
# "Operation Mode" constants

# Operation Mode Request/Return Block Formats
typeset -rA opr_fmt=(
	# requests
	[req_dirent]='00'
	[req_open]='01'
	[req_close]='02'
	[req_read]='03'
	[req_write]='04'
	[req_delete]='05'
	[req_format]='06'
	[req_status]='07'
	[req_fdc]='08'
	# returns
	[ret_read]='10'
	[ret_dirent]='11'
	[ret_std]='12'	# error open close delete status write
)

# Operation Mode Error Codes
typeset -rA opr_msg=(
	[00]='Operation Complete'
	[10]='File Not Found'
	[30]='Command Parameter or Sequence Error'
	[40]='Read Error 0'
	[41]='Read Error 1'
	[42]='Read Error 2'
	[43]='Read Error 3'
	[44]='Read Error 4'
	[45]='Disk Not Formatted' # 'Read Error 5'
	[46]='Read Error 6'
	[47]='Read Error 7'
	[48]='Read Error 8'
	[49]='Read Error 9'
	[4A]='Read Error A'
	[4B]='Read Error B'
	[4C]='Read Error C'
	[4D]='Read Error D'
	[4E]='Read Error E'
	[4F]='Read Error F'
	[50]='Write-Protected Disk'
	[60]='Disk Full'
	[70]='Disk Insertion Error 0'
	[71]='Disk Not Inserted'      # 'Disk Insertion Error 1'
	[72]='Disk Insertion Error 2'
	[73]='Disk Insertion Error 3'
	[74]='Disk Insertion Error 4'
	[75]='Disk Insertion Error 5'
	[76]='Disk Insertion Error 6'
	[77]='Disk Insertion Error 7'
	[78]='Disk Insertion Error 8'
	[79]='Disk Insertion Error 9'
	[7A]='Disk Insertion Error A'
	[7B]='Disk Insertion Error B'
	[7C]='Disk Insertion Error C'
	[7D]='Disk Insertion Error D'
	[7E]='Disk Insertion Error E'
	[7F]='Disk Insertion Error F'
	[80]='Hardware Fault 0'
	[81]='Hardware Fault 1'
	[82]='Hardware Fault 2'
	[83]='Hardware Fault 3'
	[84]='Hardware Fault 4'
	[85]='Hardware Fault 5'
	[86]='Hardware Fault 6'
	[87]='Hardware Fault 7'
	[88]='Hardware Fault 8'
	[89]='Hardware Fault 9'
	[8A]='Hardware Fault A'
	[8B]='Hardware Fault B'
	[8C]='Hardware Fault C'
	[8D]='Hardware Fault D'
	[8E]='Hardware Fault E'
	[8F]='Hardware Fault F'
)

# Directory Entry Search Forms
typeset -rA dirent_cmd=(
	[set_name]=0
	[get_first]=1
	[get_next]=2
)

# File Open Access Modes
typeset -rA open_mode=(
	[write_new]=1
	[write_append]=2
	[read]=3
)

###############################################################################
# "FDC Mode" constants


# FDC Mode Commands
typeset -rA fdc_cmd=(
	[mode]='M'
	[condition]='D'
	[format]='F'
	[formatnv]='G'
	[readid]='A'
	[readsect]='R'
	[searchid]='S'
	[writeid]='B'
	[writeidnv]='C'
	[writesect]='W'
	[writesectnv]='X'
)

# FDC Mode Errors
typeset -rA fdc_msg=(
	[0]="OK"
	[193]="Command Error"
)

###############################################################################
# generic/util functions

abrt () {
	echo "$0: $@" >&2
	exit 1
}

vecho () {
	local -i l=$1 ;shift
	((v>=l)) && echo "$@" >&2
	:
}

_sleep () {
	local x
	read -t ${1:-1} -u 4 x
}

# Convert a plain text string to hex pairs stored in hex[]
mk_hex () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local x=$* ;local -i i l=${#x} ;hex=()
	for ((i=0;i<l;i++)) { printf -v hex[i] '%02x' "'${x:i:1}" ; }
	vecho 1 "$z: hex=(${hex[*]})"
}

# Read a local file into hex pairs stored in hex[]
file_to_hex () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local x ;hex=()

	exec 5<"$1"
	while IFS= read -r -d $'\0' -n 1 -u 5 x ;do
		printf -v x '%02x' "'$x"
		hex+=($x)
	done
	exec 5<&-

	vecho 1 "$z: bytes read: ${#hex[*]}"
}

###############################################################################
# Main Command Dispatcher

do_cmd () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local -i i e ;local s="$@" a=() c ifs=$IFS IFS=';' ;a=($s) IFS=$ifs
	for ((i=0;i<${#a[*]};i++)) {
		set ${a[i]}
		c=$1 ;shift
		err_msg=
		case $c in

	# operation-mode commands
	# All of the drive firmware "operation mode" functions.
	# Most of these are low-level, not used directly by a user.
	# Higher-level commands like ls, load, & save are built out of these.
			dirent) ocmd_dirent ;e=$? ;;
			open) ocmd_open $* ;e=$? ;;
			close) ocmd_close ;e=$? ;;
			read) ocmd_read $* ;e=$? ;;
			write) ocmd_write $* ;e=$? ;;
			ocmd_delete) ocmd_delete ;e=$? ;;
			format) ocmd_format ;e=$? ;;
			stat|status) ocmd_status ;e=$? ;((e)) || echo "OK" ;;
			fdc) ocmd_fdc ;e=$? ;;

	# fdc-mode commands
	# All of the drive firmware "FDC mode" functions.
			${fdc_cmd[mode]}|mode) fcmd_mode $* ;e=$? ;; # select operation-mode or fdc-mode
			${fdc_cmd[condition]}|condition) fcmd_condition $* ;e=$? ;; # get drive condition
# name conflict 	#${fdc_cmd[format]}|format) fcmd_format $* ;e=$? ;; # format disk
			#${fdc_cmd[formatnv]}|formatnv) fcmd_formatnv $* ;e=$? ;; # format disk no verify
			#${fdc_cmd[readid]}|readid) fcmd_readid $* ;e=$? ;; # read id
			#${fdc_cmd[readsect]}|readsect) fcmd_readsect $* ;e=$? ;; # read sector
			#${fdc_cmd[searchid]}|searchid) fcmd_searchid $* ;e=$? ;; # search id
			#${fdc_cmd[writeid]}|writeid) fcmd_writeid $* ;e=$? ;; # write id
			#${fdc_cmd[writeidnv]}|writeidnv) fcmd_writeidnv $* ;e=$? ;; # write id no verify
			#${fdc_cmd[writesect]}|writesect) fcmd_writesect $* ;e=$? ;; # write sector
			#${fdc_cmd[writesectnv]}|writesectnv) fcmd_writesectnv $* ;e=$? ;; # write sector no verify

	# local/client commands
	# High-level commands like "ls", and things like "exit"
			ls|dir|list) lcmd_ls "$@" ;e=$? ;;
			rm|del|delete) lcmd_rm "$@" ;e=$? ;;
			load) lcmd_load "$@" ;e=$? ;;
			save) lcmd_save "$@" ;e=$? ;((e)) && vecho 1 "save err=$?" ;;
			sync|drain) tpdd_iosync ;e=$? ;;
			q|quit|bye|exit) exit ;;

	# low level manual raw/debug commands
			com_test) lcmd_com_test ;e=$? ;; # check if port open
			com_open) lcmd_com_open ;e=$? ;; # open the port
			com_close) lcmd_com_close ;e=$? ;; # close the port
			com_read) lcmd_com_read $* ;e=$? ;; # read $1 bytes
			com_write) lcmd_com_write $* ;e=$? ;; # write $* (hex pairs)
			com_ret) lcmd_com_ret ;e=$? ;; # read a return packet
			com_req) lcmd_com_req $* ;e=$? ;; # write a request packet
			sum) calc_cksum $* ;e=$? ;;

	# playground
			# send the TPDD1 bootstrap S-records
			tpdd1_boot) lcmd_tpdd1_boot ;e=$? ;;

			'') : ;;
			*) echo "Unknown command: \"$c\"" >&2 ;;
		esac
		((${#err_msg})) && echo "$c:$err_msg" >&2
		return $e
	}
}

###############################################################################
# experimental junk

lcmd_tpdd1_boot () {
	local x=
	mk_hex "S10985157C00AD7EF08B3AS901FE"
	tpdd_write ${hex[*]} 0d
	while tpdd_read 1 ;do x+=" ${rdh[*]}" ;done
	printf '%b' "\x${x// /\\x}"
}

###############################################################################
# serial port operations

get_tpdd_port () {
	local x=(/dev/${TPDD_TTY_PREFIX#/dev/}*)
	[[ "${x[0]}" == "/dev/${TPDD_TTY_PREFIX}*" ]] && x=(/dev/tty*)
	((${#x[*]}==1)) && { PORT=${x[0]} ;return ; }
	local PS3="Which serial port is the TPDD drive on? "
	select PORT in ${x[*]} ;do [[ -c "$PORT" ]] && break ;done
}

test_com () {
	{ : >&3 ; } 2>&-
}

open_com () {
	test_com && return
	exec 3<>"${PORT}"
	stty ${stty_f} "${PORT}" ${STTY_FLAGS}
	test_com || abrt "Failed to open serial port \"${PORT}\""
}

close_com () {
	exec 3>&-
}

###############################################################################
# TPDD communication primitives

# write $* to com port as binary
tpdd_write () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local x=$* ;rdh=()
	((v>2)) && { local c=$((10000+seq++)) ;printf '%b' "\x${x// /\\x}" >${0##*/}.$$.${c#?}.$z ; }
	printf '%b' "\x${x// /\\x}" >&3
}

# read $1 bytes from com port
# store each byte as a hex pair in global rdh[]
# deep brute force magic here to actually read null bytes
# (we're not actually reading or storing nulls, but we are *detecting* them and recording where they were)
# Thanks to Andrew Ayers in the M100 group on Facebook for help finding the key trick.
#
# return value from "read" is crucial to distiguish a timeout from a null byte
# $?=0 = we read a non-null byte normally, $x contains a byte
#    1 = we read a null byte, $x is empty because we ate the null as a delimiter
# >128 = we timed out, $x is empty because there was no data, not even a null
tpdd_read () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local -i i l=$1 ;local x ;rdh=() read_err=0
	tpdd_wait
	vecho 1 -n "$z: l=$l "
	for ((i=0;i<l;i++)) {
		vecho 1 -n " $i:"
		x= rdh[i]='00'
		((read_err)) && { vecho 1 -n "XX" ; continue ; }
		IFS= read -t $read_timeout -r -d $'\0' -n 1 -u 3 x ;read_err=$?
		(($read_err>1)) || read_err=0
		printf -v rdh[i] '%02x' "'$x"
		vecho 1 -n "${rdh[i]}"
	}
	((v>2)) && { local c=$((10000+seq++)) ;x="${rdh[*]}" ;printf '%b' "\x${x// /\\x}" >${0##*/}.$$.${c#?}.$z ; }
	vecho 1 " read_err:$read_err"
}

# check if data is available without consuming any
tpdd_check () {
	IFS= read -t 0 -u 3
}

# wait for data
tpdd_wait () {
	local z=${FUNCNAME[0]} ;vecho 1 -n "$z($@):"
	local -i i=-1 n wait_ms=${1:-${TPDD_WAIT_TIMEOUT_MS}}
	((wait_ms<=READ_TIMEOUT_MS)) && n=1 || n=$((wait_ms/READ_TIMEOUT_MS))
	until ((++i>n)) ;do
		tpdd_check && break
		_sleep $read_timeout
	done
	vecho 1 "$i"
}

# Drain any pending output from the drive.
# Read and discard bytes one at a time until hitting a read timeout.
tpdd_iosync () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	while tpdd_check ;do tpdd_read 1 ;done
	rdh=()
}

###############################################################################
#                             OPERATION MODE                                  #
###############################################################################
#
# operation-mode transaction format reference
#
# request block
#
#   preamble  2 bytes       5A5A
#   format    1 byte        type of request block
#   length    1 byte        length of data in bytes
#   data      0-128 bytes   data
#   checksum  1 byte        1's comp of LSByte of sum of format through data
#
# return block
#
#   format    1 byte        type of return block
#   length    1 byte        length of data in bytes
#   data      0-128 bytes   data
#   checksum  1 byte        1's comp of LSByte of sum of format through data



###############################################################################
# "Operation Mode" support functions

# calculate the checksum of $* (hex pairs)
# return in global $cksum (hex pair)
calc_cksum () {
	local z=${FUNCNAME[0]} ;vecho 1 -n "$z($@):"
	local -i s=0
	while (($#)) ;do ((s+=16#$1)) ;shift ;done
	s=$(((s&255)^255))
	printf -v cksum '%02x' $s
	vecho 1 "$cksum"
}

# verify the checksum of a received packet
# $* = data data data... csum  (hex pairs)
verify_checksum () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local -i l=$(($#-1)) ;local x= h=($*)
	x=${h[l]} ;h[l]=
	calc_cksum ${h[*]}
	vecho 1 "$z: received: \"$x\""
	vecho 1 "$z: computed: \"$cksum\""
	[[ "$x" == "$cksum" ]]
}

# check if a ret_std format response was ok (00) or error
ocmd_check_err () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local -i e ;local x
	vecho 1 "$z: ret_fmt=$ret_fmt ret_len=$ret_len ret_dat=(${ret_dat[*]}) read_err=\"$read_err\""
	((${#ret_dat[*]}==1)) || { err_msg+=" Corrupt Response" ; ret_dat=() ;return 1 ; }
	vecho 1 -n "$z: ${ret_dat[0]}:"
	e=$((16#${ret_dat[0]}))
	x='OK'
	((e)) && {
		x='UNKNOWN ERROR'
		((${#opr_msg[${ret_dat[0]}]})) && x="${opr_msg[${ret_dat[0]}]}"
		err_msg+=" $x"
	}
	vecho 1 "$x"
	return $e
}

# build a valid operation-mode request block and send it to the tpdd
# 5a 5a format length data checksum
# fmt=$1  data=$2-*
ocmd_send_req () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	((operation_mode)) || fcmd_mode 1
	local fmt=$1 len ;shift
	printf -v len '%02x' $#
	calc_cksum $fmt $len $*
	vecho 1 "$z: fmt=\"$fmt\" len=\"$len\" dat=\"$*\" sum=\"$cksum\""
	tpdd_write 5a 5a $fmt $len $* $cksum
}

# read an operation-mode return block from the tpdd
# parse it into the parts: format, length, data, checksum
# verify the checksum
# return the globals ret_fmt, ret_len, ret_dat[], ret_sum
ocmd_read_ret () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local -i t ;local l x ;ret_fmt= ret_len= ret_dat=() ret_sum=

	# read 2 bytes (fmt len)
	# Retry this a couple times, and accept "00 00" as a valid response even
	# though according to the manual it's NOT. After doing ocmd_close()
	# after ocmd_write() we might read 2 00 bytes, and then get an error
	# from the read command if we try to read any more. But if we pause a
	# few 10s of ms and try again, we get the expected normal format 12h
	# return block that the manual promised, and, the data byte is even 00
	# (indicating success). Unclear why the drive is issuing null bytes.
	for ((t=1;t<3;t++)) {
	vecho 1 "$z: read 2 bytes (fmt len)"
	tpdd_read 2
	vecho 1 "$z: (${rdh[*]})"
	((${#rdh[*]}==2)) || return 1
	case "${rdh[0]}" in
		10|11|12) ret_fmt=${rdh[0]} ret_len=${rdh[1]} ; break ;;
		00) vecho 1 "READ TRY# $t 00 00" ;_sleep 0.5 ;continue ;;
		*) vecho 1 "READ TRY# $t INVALID RESPONSE" ;rdh=() ;return 2 ;;
	esac
	}

	# read <length> bytes (data)
	l=$((16#$ret_len))
	vecho 1 "$z: read 0x$ret_len($l) bytes (data)"
	tpdd_read $l
	((${#rdh[*]}==l)) || return 3
	ret_dat=(${rdh[*]})
	vecho 1 "$z: data=(${ret_dat[*]})"

	# read 1 byte (checksum)
	vecho 1 "$z: read 1 byte (checksum)"
	tpdd_read 1
	((${#rdh[*]}==1)) || return 4
	ret_sum=${rdh[0]}
	vecho 1 "$z: cksum=$ret_sum"

	# compute our own checksum and verify it matches the supplied checksum
	verify_checksum $ret_fmt $ret_len ${ret_dat[*]} $ret_sum || { err_msg+=" CHECKSUM FAILED" ; return 5 ; }
}

# Space-pad or truncate $1 to 24 bytes.
# If in "Floppy Compatible" mode, and if the filename is already 6.2 or less,
# then also space-pad to %-6s.%-2s within that. Return in global tpdd_file_name
# normal       : "hi.bat"                -> "hi.bat                  "
# floppy_compat: "A.CO"   -> "A     .CO" -> "A     .CO               "
# floppy_compat: "Floppy_SYS"            -> "Floppy_SYS              "
mk_tpdd_file_name () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local -i e ;local x t f="$1" ;tpdd_file_name=

	$FLOPPY_COMPAT && {
		t=${1%.*} x=${1##*.}
		((${#t})) && ((${#t}<7)) && ((${#x}<3)) && printf -v f '%-6s.%-2s' "$t" "$x"
	}

	printf -v tpdd_file_name '%-24.24s' "$f"
}

###############################################################################
# "Operation Mode" drive functions
# wrappers for each "operation mode" function of the drive firmware

# directory entry
# fmt = 00
# len = 1a
# filename = 24 bytes
# attribute = "F" (always)
# search form = 00=set_name | 01=get_first | 02=get_next
ocmd_dirent () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local -i e ;local x f="$1" m=${3:-${dirent_cmd[get_first]}}
	drive_err= file_name= file_attr= file_len= free_sectors=
	((operation_mode)) || fcmd_mode 1

	# construct the request
	mk_tpdd_file_name "$f"			# pad/truncate filename
	mk_hex "$tpdd_file_name"		# filename (hex[0-23])
	printf -v hex[24] '%02x' "'${2:-F}"	# attribute - always "F"
	printf -v hex[25] '%02x' $m		# search form (set_name, get_first, get_next)

	# send the request
	ocmd_send_req ${opr_fmt[req_dirent]} ${hex[*]} || return $?

	# read the response
	ocmd_read_ret || return $?

	# check which kind of response we got
	case "$ret_fmt" in
		"${opr_fmt[ret_std]}") ocmd_check_err || return $? ;;
		"${opr_fmt[ret_dirent]}") : ;;
		*) err_msg+=" $z:Corrupt Return" ;return 1 ;;
	esac
	((${#ret_dat[*]}==28)) || { err_msg+=" $z:Corrupt Return" ;return 1 ; }

	# parse a dirent return format
	free_sectors=$((16#${ret_dat[27]})) ;ret_dat[27]=
	file_len=$(( 16#${ret_dat[25]}*256 + 16#${ret_dat[26]} )) ;ret_dat[26]= ret_dat[25]=
	printf -v file_attr '%b' "\x${ret_dat[24]}" ;ret_dat[24]=
	x=(${ret_dat[*]}) ;x="${x[*]}" ;printf -v file_name '%-24.24b' "\x${x// /\\x}"
	vecho 1 "$z: mode=$m filename=\"$file_name\" attr=\"$file_attr\" len=$file_len free=$free_sectors"

	# if doing set_name
	[[ "$m" == "${dirent_cmd[set_name]}" ]] && {
		# file_attr=00 could mean invalid filename or file not found,
		# so we don't know here whether that's an error or not.
		# The caller will have to look at $filename and $file_attr
		# decide for itself.
		#((${#file_attr})) || { err_msg+=" $z:Invalid Filename" ; return 1 ; }
		return 0
	}

	# get_first/get_next, filename[0]=00 means no more files
	[[ ${ret_dat[0]} == '00' ]] && return 1 || return 0
}

# Get Drive Status
# request: 5a 5a 07 00 ##
# return : 07 01 ?? ##
ocmd_status () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	((operation_mode)) || fcmd_mode 1
	ocmd_send_req ${opr_fmt[req_status]} || return $?
	ocmd_read_ret || return $?
	ocmd_check_err || return $?
}

# Format Disk
#request: 5a 5a 06 00 ##
#return : 12 01 ?? ##
ocmd_format () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	((operation_mode)) || fcmd_mode 1

	echo "Formatting disk..."
	ocmd_send_req ${opr_fmt[req_format]} || return $?
	tpdd_wait 120000 || return $?	# takes ~100 seconds, allow 120

	ocmd_read_ret || return $?
	ocmd_check_err || return $?
}

# switch to FDC mode
ocmd_fdc () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	ocmd_send_req ${opr_fmt[req_fdc]} || return $?
	operation_mode=0
}

# Open File
# request: 5a 5a 01 01 MM ##
# return : 12 01 ?? ##
# MM = access mode: 01=write_new, 02=write_append, 03=read
ocmd_open () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	((operation_mode)) || fcmd_mode 1
	local m ;printf -v m '%02x' $1
	ocmd_send_req ${opr_fmt[req_open]} $m || return $?	# open the file
	ocmd_read_ret || return $?
	ocmd_check_err
}

# Close File
# request: 5a 5a 02 00 ##
# return : 12 01 ?? ##
ocmd_close () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	((operation_mode)) || fcmd_mode 1
	ocmd_send_req ${opr_fmt[req_close]} || return $?
	tpdd_wait 10000 || return $? #  XXX TODO may not need
	ocmd_read_ret || return $?
	ocmd_check_err
}

# Delete File
# request: 5a 5a 05 00 ##
# return : 12 01 ?? ##
ocmd_delete () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	((operation_mode)) || fcmd_mode 1
	ocmd_send_req ${opr_fmt[req_delete]} || return $?
	tpdd_wait 10000 || return $?	# takes ~5 seconds, allow 10
	ocmd_read_ret || return $?
	ocmd_check_err
}

# Read File data
# request: 5a 5a 03 00 ##
# return : 10 00-80 1-128bytes ##
ocmd_read () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	((operation_mode)) || fcmd_mode 1
	ocmd_send_req ${opr_fmt[req_read]} || return $?
	ocmd_read_ret || return $?
	vecho 1 "$z: ret_fmt=$ret_fmt ret_len=$ret_len ret_dat=(${ret_dat[*]}) read_err=\"$read_err\""

	# check if the response was an error
	case "$ret_fmt" in
		"${opr_fmt[ret_std]}") ocmd_check_err || return $? ;;
		"${opr_fmt[ret_read]}") ;;
		*) err_msg+=" Unexpected Response" ;return 4 ;;
	esac

	# return true or not based on data or not
	# so we can do "while ocmd_read ;do ... ;done"
	((${#ret_dat[*]}))
}

# Write File Data
# request: 5a 5a 04 ?? 1-128 bytes ##
# return : 12 01 ?? ##
ocmd_write () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	((operation_mode)) || fcmd_mode 1
	(($#)) || return 128
	ocmd_send_req ${opr_fmt[req_write]} $* || return $?

	# arbitrary forced sleep, without tpdd_check()
	# because if you tpdd_check() too soon, it will succeed, indicating
	# "there is data available, you need to read it", but if you do try to
	# read, the bytes you get will just be 00. But if you wait a bit before
	# trying, then the bytes you get will be the expected 12h return block.
	#_sleep 0.5

	# manual says no return block is sent unless there's an error
	tpdd_check || return 0

	ocmd_read_ret || return $?
	ocmd_check_err
}

###############################################################################
#                                 FDC MODE                                    #
###############################################################################
#
# fdc-mode transaction format reference
#
# send: C [ ] [P[,P]...] CR
#
# C = command letter, ascii letter
# optional space between command letter and first parameter
# P = parameter (if any), integer decimal value in ascii numbers
# ,p = more parameters if any, seperated by commas, ascii decimal numbers
# CR = carriage return
#
# recv: 8 bytes as 4 ascii hex pairs representing 4 byte values
#
#  1st pair is the error status
#  remaining pairs meaning depends on the command
#
# Some fdc commands have another send-and-receive after that.
# Receive the first response, if the status is not error, then:
#
# send: the data for a sector write
# recv: another standard 8-byte response as above
# or
# send: single carriage-return
# recv: data from a sector read

###############################################################################
# "FDC Mode" support functions

# read an FDC-mode 8-byte result packet
fcmd_read_result () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	((operation_mode)) && ocmd_fdc
	local -i i ;local x ;fdc_err= fdc_res= fdc_len= fdc_res_b=()

	# read 8 bytes
	tpdd_read 8

	# re-constitute the 8 hex pairs from tpdd_write(), back to the original
	# 8 ascii characters sent by the drive
	x="${rdh[*]}" ;printf -v x '%b' "\x${x// /\\x}"
	vecho 1 "$z:$x"

	# the 8 characters sent by the drive are themselves hex pairs,
	# representing integer values not ascii characters in this case
	fdc_err=$((16#${x:0:2})) # first 2 status
	fdc_res=$((16#${x:2:2})) # next 2  result
	fdc_len=$((16#${x:4:4})) # last 4  length

	# look up the error message for fdc_err if not 0
	((v)) && {
		x='OK'
		((fdc_err)) && {
			x='ERROR'
			[[ "${fdc_msg[fdc_err]}" ]] && x="${fdc_msg[fdc_err]}"
			err_msg+=" $x"
		}
		vecho 1 -n "$z:status: $fdc_err - $x"
	}

	# fdc_result is 8 individual bits
	# convert to an array for convenience
	fdc_result_b=()
	for ((i=7;i>=0;i--)) { fdc_result_b+=(${D2B[fdc_res]:i:1}) ; }

	return $fdc_err
}

###############################################################################
# "FDC Mode" drive functions
# wrappers for each "FDC mode" function of the drive firmware

# select operation mode
# $1 0=fdc 1=operation
fcmd_mode () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	(($#)) || return
	mk_hex "${fdc_cmd[mode]}$1"
	tpdd_write ${hex[*]} 0d
	operation_mode=$1
}

fcmd_condition () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	((operation_mode)) && ocmd_fdc
	local -i ;local x
	mk_hex "${fdc_cmd[condition]}"
	tpdd_write ${hex[*]} 0d

	fcmd_read_result
	((fdc_status)) && return $fdc_status

	# result bit 7 - disk not inserted
	x= ;((fdc_result_b[7])) && x=' Not'
	echo -n "Disk${x} Inserted"
	((fdc_result_b[7])) && { echo ;return ; }

	# result bit 5 - disk write-protected
	x='Writable' ;((fdc_result_b[5])) && x='Write-protected'
	echo ", $x"
}

###############################################################################
# Local Commands
# high level functions implemented here in the client

# list all files
lcmd_ls () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local -i dirent_mode=${dirent_cmd[get_first]} i= ;local f x ;ret_dat=()

	while ocmd_dirent '' '' $dirent_mode ;do
		# If in "Floppy Compatible" mode, and it looks like a
		# "Model T" filename, then collapse the internal spaces.
		$FLOPPY_COMPAT && {
			f=${file_name// /} ;x=${f##*.} ;f=${f%.*}
			((${#f})) && ((${#f}<7)) && ((${#x}<3)) && printf -v file_name '%s.%s' "$f" "$x"
		}

		printf '%-24.24b %6u\n' "$file_name" "$file_len"
		((dirent_mode==${dirent_cmd[get_first]})) && dirent_mode=${dirent_cmd[get_next]}
	done
}

# load a file (copy a file from tpdd to local fs)
# lcmd_load source_filename [destination_filename]
lcmd_load () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local x s d ;local -i p=
	[[ "$1" ]] || return 1
	s=$1 d=${2:-$s}
	ocmd_dirent "$s" '' ${dirent_cmd[set_name]} || return $?	# set the source filename
	ocmd_open ${open_mode[read]} | return $?	# open the source file for reading
	>"$d"						# start the destination file
	while ocmd_read ;do				# read a block of data from tpdd
		x="${ret_dat[*]}"
		printf '%b' "\x${x// /\\x}" >> "$d"	# write the block of data to the destination file
		((${#ret_dat[*]}<128)) && break		# stop when we get less than 128 bytes
	done
	ocmd_close					# close the source file
}

# save a file (copy a file from local fs to tpdd)
# lcmd_save source_filename [destination_filename]
lcmd_save () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	local -i i n e p= ;local s d w h x
	[[ "$1" ]] || return 2
	s=$1 d=${2:-$1}
	file_to_hex "$s" || return 3 ;h=(${hex[*]})	# read the source file into h[]
	ocmd_dirent "$d" '' ${dirent_cmd[set_name]} || return $?	# set the destination filename
	ocmd_open ${open_mode[write_new]} || return $?		# open the set file for writing
	while ((${#h[*]})) ;do
		vecho 1 "$z: packet:$((++p)) start #h=${#h[*]}"

		w=() n=${#h[*]}				# move 128 bytes into w[]
		((n>128)) && n=128
		for ((i=0;i<n;i++)) { w+=(${h[i]}) h[i]= ; } ;h=(${h[*]})
		vecho 1 "$z: packet:$p end #h=${#h[*]}"

		ocmd_write ${w[*]} || return $?		# write w[] to the set file

		tpdd_wait				# read the response from write
		ocmd_read_ret || return $?
		ocmd_check_err || return $?

	done
	ocmd_close || return $?			# close the set file
}


lcmd_rm () {
	local z=${FUNCNAME[0]} ;vecho 1 "$z($@)"
	[[ "$1" ]] || return 1
	ocmd_dirent "$1" '' ${dirent_cmd[set_name]} || return $?	# set the filename
	ocmd_delete
}

###############################################################################
# manual/raw debug commands

lcmd_com_test () {
	test_com && echo "com is open" || echo "com is closed"
}

lcmd_com_open () {
	open_com
	lcmd_com_test
}

lcmd_com_close () {
	close_com
	lcmd_com_test
}

lcmd_com_read () {
	tpdd_read $1
	printf '%s\n' "${rdh[@]}"
}

lcmd_com_write () {
	tpdd_write $*
}

lcmd_com_ret () {
	ocmd_read_ret
	printf '%s\n' "${ret_dat[@]}"
}

lcmd_com_req () {
	ocmd_send_req $*
}

###############################################################################
# Main
typeset -a hex=() rdh=() ret_dat=() fdc_res_b=()
typeset -i operation_mode=1 read_err= fdc_err= fdc_res= fdc_len=
cksum=00 ret_fmt= ret_len= ret_sum= err_msg= tpdd_file_name= file_name=
readonly LANG=C D2B=({0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1})
((v>2)) && typeset -i seq=0
x=$((1000000+READ_TIMEOUT_MS)) ;readonly read_timeout="${x:1:-3}.${x: -3}" ;unset x

# for _sleep()
readonly sleep_fifo=/tmp/.${0//\//_}.$$.sleep.fifo
trap "rm -f $sleep_fifo" EXIT
mkfifo $sleep_fifo || abrt "Error creating sleep fifo \"$sleep_fifo\""
exec 4<>$sleep_fifo

# tpdd serial port
PORT="/dev/${1#/dev/}" ;[[ -c "$PORT" ]] && shift || get_tpdd_port
vecho 1 "Using port \"$PORT\""
open_com || exit $?

# non-interactive mode
(($#)) && { do_cmd "$@" ; exit ; }

# interactive mode
while read -p"TPDD(${mode[operation_mode]})>" x ;do do_cmd "$x" ;done
